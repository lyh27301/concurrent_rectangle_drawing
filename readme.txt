The goal here is to use multiple threads efficiently to draw rectangles on an image. Rectangles are axis-aligned, drawn with a 1-pixel thick black border, but filled in with a random colour. 20 Each thread repeatedly attempts to draw a random rectangle. It chooses a random spot to start (a corner or center, up to you) and a random size (within the image limits), and ensures the resulting rectangle at that location will not overlap with other in-progress rectangles, and draws it. Once a thread starts drawing a rectangle it must fully complete the process. You may not use any built-in line, rectangle, or filling primitives to do this.
draw.java that accepts the following command-line arguments, w, h, n, and k. It should launch n threads to draw a total of k rectangles on a w ¡Á h image. Note that n may or may not evenly divide k.

Choose w,h,k such that the program typically takes a few seconds (or at least several hundreds of milliseconds) to run with n = 1. Timing code is added (using System.currentTimeMillis) to time the program from the point the threads are launched to the point when all threads have completed their work. Once all threads have completed, the time taken in milliseconds should be emitted as console output and the image output to a file, named outputimage.png.
Plot performance (speedup) versus the number of threads, keeping w, h, k fixed. Given the randomness, you will need still to do several runs at each thread-count (at least 5) averaging the timings (you may opt to discard the initial run as a cache-warmup). Provide a graph of the relative speedup of your multithreaded versions over the single-threaded version for 2, 3, and 4 threads. 
 
There is a separate document your performance plot with a brief textual explanation of your results (why do you get the speedup curve you get).
